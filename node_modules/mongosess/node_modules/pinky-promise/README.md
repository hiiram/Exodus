# Pinky-promise

Pinky-promise is a promise implementation for [Node.js](http://nodejs.org/). Pinky-promise is really just an extension of [jakearchibald/es6-promise](https://github.com/jakearchibald/es6-promise). It adds a few useful instance methods, but is fundamentally the same.

## Installation

```
$ npm install pinky-promise
```

## API

The standard methods are [documented elsewhere](http://www.html5rocks.com/en/tutorials/es6/promises/#toc-api), so I won't restate those here. The non-standard instance methods are as follows:

### promise.finally( onComplete )

```onComplete``` is a function that gets called whether or not the promise is resolved or rejected. It is not passed any arguments. This can be useful for, say, removing event handlers, closing a database connection, or tearing down a test. For example:

```javascript
var Promise = require('pinky-promise'),
    database = require('some-database-driver')

var promise = new Promise(function (resolve, reject) {
  database.connect(function (err, connection) {
    if (err) reject(err)
    else resolve(connection)
  })
})

promise.then(function (conection) {
  connection.queryStuff()
}).catch(function (err) {
  console.log(err, err.stack)
}).finally(function () {
  database.disconnect()
})

// Note that you could also have done:
// etcEtc.finally(database.disconnect)
```

### promise.done( )

This throws any unhandled errors, so that they can escape the context of the promise. Consider the following:

```javascript
// This is a bit contrived; in real life, you'd probably want to use
// this with an async operation that you're unsure will succeed.
var promise = Promise.reject(new Error('Whoops!'))

promise.then(function (val) {
  doStuff(val)
})
```

There is an unhandled error, but it goes unnoticed. To fix this, we'll use ```done```:

```javascript
var promise = Promise.reject(new Error('Whoops!'))

promise.then(function (val) {
  doStuff(val)
}).done()
```

In this case, the error will be thrown in whatever context the above code was in.

```done``` returns null, ending any promise chaining.

### promise.timeout( time [, message ] )

Causes the promise to be rejected after ```time``` ms if it does not settle on its own by then. By default, promises are rejected with ```new Error('Promise timed out.')``` To specify the error message, you can pass a message as the second argument. Example:

```javascript
var promise = new Promise(function (resolve, reject) {
  someAsyncThing(function (err, result) {
    if (err) reject(err)
    else resolve(result)
  })
})

promise
  .timeout(100, 'someAsyncThing failed.')
  .then(function (val) {
    console.log('Success!')
  }, function (err) {
    console.log(err, err.stack)
  })
```

In this example, the promise will reject with ```new Error('someAsyncThing failed.')``` if someAsyncThing does not complete within 100ms.

### promise.nodeify( callback )

Let's say you're making an async API; you want to return Promises to those who want them, but also want it to work with regular old callbacks. You might do something like this:

```javascript
function asyncThing (callback) {
  var p = new Promise(function (reject, resolve) {
    asyncStuff(function (err, result) {
      if (err) reject(err)
      else resolve (result)
    })
  })
  
  return p.then(function (result) {
    if (callback) callback(null, result)
    return result
  }, function (err) {
    if (err) callback(err)
    throw err
  })
}
```

```promise.nodeify( )``` is basically just a shorthand for this. You can use promises like you would normally, and, once done, call ```nodeify( callback )```. If callback is not undefined, it will will pass the result of the promise to the callback as appropriate. The example above thus becomes:

```javascript
function asyncThing (callback) {
  var p = new Promise(function (reject, resolve) {
    asyncStuff(function (err, result) {
      if (err) reject(err)
      else resolve (result)
    })
  })
  
  return p.nodeify(callback)
}
```

## License

MIT. See [LICENSE](https://github.com/lucthev/pinky-promise/blob/master/LICENSE.txt)