var Promise = require('../promise.js')

describe('The non-standard instance methods:', function () {
  
  describe('finally:', function () {
    
    it('should get called if the promise is fulfilled.', function (done) {
      var p = Promise.resolve(4)

      p.finally(function () {

        // Just make sure it got called:
        expect(true).toBe(true)
        done()
      })
    })

    it('should get called if the promise is rejected.', function (done) {
      var p = Promise.reject(new Error('Whoops!'))

      p.finally(function () {

        // Just make sure it got called:
        expect(true).toBe(true)
        done()
      })
    })

    it('should not be passed any arguments when resolved.', function (done) {
      var p = Promise.resolve(4)

      p.finally(function (arg) {
        expect(arg).toBe(undefined)
        done()
      })
    })

    it('should not be passed any arguments when rejected.', function (done) {
      var p = Promise.reject(new Error('Whoops'))

      p.finally(function (arg) {
        expect(arg).toBe(undefined)
        done()
      })
    })

    it('should be called when the promise resolves async.', function (done) {
      var p = Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve(4)
        }, 50)
      })

      p.finally(function () {
        expect(true).toBe(true)
        done()
      })
    })

    it('should be called when the promise rejects async.', function (done) {
      var p = Promise(function (resolve, reject) {
        setTimeout(function () {
          reject(new Error('Whoops'))
        }, 50)
      })

      p.finally(function () {
        expect(true).toBe(true)
        done()
      })
    })

    it('should be called in the order it is added.', function (done) {
      var a = []

      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve(4)
        }, 50)
      })

      p.then(function (val) {
        a.push(1)
      })

      p.finally(function () {
        a.push(2)
      })

      p.finally(function () {
        a.push(3)
      })

      setTimeout(function () {
        expect(a[0]).toEqual(1)
        expect(a[1]).toEqual(2)
        expect(a[2]).toEqual(3)
        done()
      }, 150)
    })
  })

  describe('done:', function () {
    
    it('should not be chainable.', function (done) {
      var p = Promise.resolve(4)

      expect(function () {
        p.done().then(function (val) {
          return val
        })
      }).toThrow()

      setTimeout(function () {
        done()
      }, 20)
    })

    it('should not do anything if there are no unhandled errors.', function (done) {
      var p = Promise.resolve(4)

      expect(function () {
        p.done()
      }).not.toThrow()

      setTimeout(function () {
        done()
      }, 20)
    })

    // FIXME: I have no idea how to test functions that throw async.
    // From brief actual usage, though, it works.

    xit('should throw unhandled errors', function () {
      var p = Promise.reject(new Error('Whoops'))

      expect(function () {
        p.done()
      }).toThrow()
    })

    xit('should throw async unhandled errors.', function () {
      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          reject(new Error('Whoops'))
        }, 50)
      })

      expect(function () {
        p.done()
      }).toThrow()
    })
  })

  describe('timeout:', function () {
    
    it('rejects a function after a certain amount of time. Resolve.', function (done) {
      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve(4)
        }, 200)
      })

      p.timeout(100).then(function (val) {
        throw new Error('Should not call this.')
      }, function (err) {
        expect(err).not.toBe(null)
        expect(err.message).toEqual('Promise timed out.')
        done()
      })
    })

    it('rejects a function after a certain amount of time. Reject.', function (done) {
      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          reject(new Error('Whoops'))
        }, 200)
      })

      p.timeout(100).then(function (val) {
        throw new Error('Should not call this.')
      }, function (err) {
        expect(err).not.toBe(null)
        expect(err.message).toEqual('Promise timed out.')
        done()
      })
    })

    it('should reject with a custom error message if given. Reject.', function (done) {
      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          reject(new Error('Whoops'))
        }, 200)
      })

      p.timeout(50, 'XX')
        .then(function (val) {
          throw new Error('Should not call this.')
        }, function (err) {
          expect(err).not.toBe(null)
          expect(err.message).toEqual('XX')
          done()
        })
    })

    it('should reject with a custom error message if given. Resolve.', function (done) {
      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve(4)
        }, 200)
      })

      p.timeout(50, 'XX')
        .then(function (val) {
          throw new Error('Should not call this.')
        }, function (err) {
          expect(err).not.toBe(null)
          expect(err.message).toEqual('XX')
          done()
        })
    })

    it('should not change the state of an already resolved promise.', function (done) {
      var p = Promise.resolve(4)

      p.timeout(20)

      setTimeout(function () {
        p.then(function (val) {
          expect(val).toEqual(4)
          done()
        }, function (err) {
          expect(err).toBe(null)
        })
      }, 100)
    })

    it('should not change the state of an already rejected promise.', function (done) {
      var e = new Error('Whoops')

      var p = Promise.reject(e)

      p.timeout(20)

      setTimeout(function () {
        p.then(function (val) {
          throw new Error('Cant touch this nananana.')
        }, function (err) {
          expect(err).toEqual(e)
          done()
        })
      }, 100)
    })
  })

  describe('nodeify', function () {
    
    it('calls a callback with the result of the promise. Resolve.', function (done) {
      
      function cb (err, val) {
        expect(err).toBe(null)
        expect(val).toEqual(4)
        done()
      }

      var p = Promise.resolve(4)
      p.nodeify(cb)
    })

    it('calls a callback with an error. Reject', function (done) {
      
      var error = new Error('Whoops')

      function cb (err, val) {
        expect(val).toBe(undefined)
        expect(err).toEqual(error)
        done()
      }

      var p = Promise.reject(error)
      p.nodeify(cb)
    })

    it('works async. Resolve.', function (done) {
      
      function cb (err, val) {
        expect(err).toBe(null)
        expect(val).toEqual(4)
        done()
      }

      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve(4)
        }, 50)
      })
      p.nodeify(cb)
    })

    it('works async. Reject', function (done) {
      
      var error = new Error('Whoops')

      function cb (err, val) {
        expect(val).toBe(undefined)
        expect(err).toEqual(error)
        done()
      }

      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          reject(error)
        }, 50)
      })
      p.nodeify(cb)
    })

    it('does nothing when cb is undefined. Resolve.', function (done) {
      
      var cb;

      var p = Promise.resolve(4)
      p.nodeify(cb).then(function (val) {
        expect(val).toEqual(4)
        done()
      })
    })

    it('does nothing when cb is undefined. Reject.', function (done) {
      
      var cb;

      var error = new Error('Whoops')

      var p = Promise.reject(error)
      p.nodeify(cb).catch(function (err) {
        expect(err).toEqual(error)
        done()
      })
    })

    it('does nothing when cb is undefined, async. Resolve.', function (done) {
      
      var cb;

      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve(4)
        }, 50)
      })
      p.nodeify(cb).then(function (val) {
        expect(val).toEqual(4)
        done()
      })
    })

    it('does nothing when cb is undefined, async. Reject.', function (done) {
      
      var cb;

      var error = new Error('Whoops')

      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          reject(error)
        }, 50)
      })
      p.nodeify(cb).catch(function (err) {
        expect(err).toEqual(error)
        done()
      })
    })

    it('works with chains.', function (done) {
      
      function cb (err, val) {
        expect(err).toBe(null)
        expect(val).toEqual(4)
        done()
      }

      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve('word')
        }, 100)
      })
      p.then(function (val) {
        return [1, 2, 3, 4]
      }).then(function (arr) {
        return arr[3]
      }).nodeify(cb).done()
    })
  })
})