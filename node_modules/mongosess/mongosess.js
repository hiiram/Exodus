module.exports = MongoSess

var Mongo = require('mongodb'),
    MongoClient = Mongo.MongoClient,
    ObjectID = Mongo.ObjectID,
    Cookies = require('cookies'),
    Promise = require('pinky-promise')

try {
  var KeyGrip = require('keygrip')
} catch (e) {}

var db = null,
    collection = null

// Default options.
var defaults = {
  collection: 'sessions',
  expires: 1000 * 60 * 60 * 24 * 14, // 2 weeks
  cookieName: 'sess'
}

/**
 * MongoSess() creates a new MongoSess instance.
 *
 * @param {Request Object} req
 * @param {Response Object} res
 * @param {Object} opts
 */
function MongoSess (req, res, opts) {
  if (!(this instanceof MongoSess)) {
    return new MongoSess(req, res, opts);
  }

  opts = opts || {};

  if (!db || !collection)
    throw new Error('You must be connected to MongoDB to use MongoSess');

  if (opts.keys) {
    if (!KeyGrip) {
      throw new Error('KeyGrip required to sign keys.');
    } else if (Array.isArray(opts.keys)) {
      this.keys = new KeyGrip(opts.keys);
    } else if (opts.keys instanceof KeyGrip) {
      this.keys = opts.keys;
    } else {
      throw new Error('Invalid keys provided to MongoSess.');
    }
  }

  this.cookies = new Cookies(req, res, this.keys);
  this.cookieName = opts.cookieName || defaults.cookieName;
  this.cookieOpts = {
    signed: !!this.keys
  };

  // Set cookie expiration if necessary. 
  if (opts.expires !== 0) {
    this.cookieOpts.expires = 
      new Date(Date.now() + (opts.expires || defaults.expires));
  }

  // Get session id.
  this.sid = this.cookies.get(this.cookieName, this.cookieOpts);

  if (!this.sid) {

    // No session id found; create new one.
    this.sid = '' + ObjectID().valueOf();
    this.cookies.set(this.cookieName, this.sid, this.cookieOpts);
  }
}

/**
 * MongoSess.get() gets the session variable associated with 'key'.
 * 
 * @param {String} key (optional)
 * @param {Function} cb
 * @api public
 */
MongoSess.prototype.get = function (key, cb) {

  var sid = this.sid
 
  if (typeof key === 'function') {
    cb = key
    key = null
  }  

  var promise = new Promise(function (resolve, reject) {
    
    if (!db || !collection)
      return reject(new Error('Not connected to MongoDb.'))

    collection.findOne({ _id: sid }, function (err, doc) {
      if (err) reject(err)
      else resolve(doc)
    })
  })

  return promise.then(function (doc) {
    return doc || { _id: sid }
  }).then(function (doc) {
    if (key)
      return doc[key]
    else return doc
  }).nodeify(cb)
}

/**
 * MongoSess.set() sets the sessions variables
 *
 * @param {Object} data
 * @param {Function} cb
 */
MongoSess.prototype.set = function (data, cb) {

  var sid = this.sid
  
  var promise = new Promise(function (resolve, reject) {
    if (!data || typeof data === 'function')
      return reject(new Error('Cannot update null.'))

    if (!sid)
      return reject(new Error('Could not find session id.'))

    if (data.hasOwnProperty('_id'))
      return reject(new Error('Cannot modify _id field.'))

    collection.update({ '_id': sid },
      { $set: data, $setOnInsert: { createdAt: new Date() }},
      { 'upsert': true, 'safe': true }, function (err, set) {
        if (err) reject(err)
        else resolve(set)
      })
  })

  return promise.nodeify(cb)
}

/**
 * MongoSess.del() deletes session variables.
 *
 * @param {String} keys
 * @param {Function} cb
 * @api public
 */
MongoSess.prototype.del = function () {
  var props = {},
      sid = this.sid,
      cb,
      i

  for (i = 0; i < arguments.length; i += 1) {
    if (typeof arguments[i] === 'string') {
      props[arguments[i]] = 1
    } else if (typeof arguments[i] === 'function') {
      cb = arguments[i]
    }
  }

  var promise = new Promise(function (resolve, reject) {
    
    if (props._id)
      reject(new Error('Cannot delete _id field.'))

    if (!sid)
      reject(new Error('Could not find session id.'))

    collection.update(
      { '_id': sid }, { $unset: props }, { 'safe': true },
      function (err, result) {
        if (err) reject(err)
        else resolve(result)
      })
  })

  return promise.nodeify(cb)
}

/**
 * MongoSess.end() removes current session from the collection.
 *
 * @param {Function} cb
 * @api public
 */
MongoSess.prototype.end = function (cb) {

  var promise = new Promise(function (resolve, reject) {
    collection.remove({ '_id': this.sid }, function (err, removed) {
      if (err) reject(err)

      // Delete cookies.
      this.cookies.set(this.cookieName, '', {
        expires: new Date(0),
        signed: !!this.keys
      })

      resolve(true)
    }.bind(this))
  }.bind(this))

  return promise.nodeify(cb)
}

/**
 * MongoSess.expire() makes the sessions cookie expire at the end of
 * the browser session.
 *
 * @api public
 */
MongoSess.prototype.expire = function () {

  if (this.cookieOpts.expires) {
    delete this.cookieOpts.expires

    this.cookies.set(this.cookieName, this.sid, this.cookieOpts)
  }
}

/**
 * createCollection() creates the session collection.
 *
 * @param {String} name
 * @param {Function} cb
 * @api private
 */
function createCollection (opts, cb) {
  if (!db) throw new Error('Not yet connected to Db.')

  if (collection) return cb && cb()


  // Collection name defaults to 'sessions'
  if (!opts.collection) opts.collection = defaults.collection

  db.collection(opts.collection, function (err, coll) {
    if (err) throw err


    collection = coll

    collection.ensureIndex({'createdAt': 1}, 
      {expireAfterSeconds: (opts.expires || defaults.expires) / 1000},
      function (err, result) {
        if (err)
          throw new Error('Error setting TTL index on collection: ' + collName)


        // All is good.
        return cb && cb()
      })
  })
}

/**
 * Setup database instance.
 *
 * @param {Object} opts
 * @param {Function} cb
 * @api public
 */
MongoSess.connect = function (opts, cb) {
  var server


  if (db && collection) {
    return cb && cb()
  }

  if (typeof opts !== 'object' || typeof cb !== 'function') {
    throw new Error('Invalid MongoSess connection parameters.\n')
  }

  if (!Array.isArray(opts.servers)) {
    throw new Error('Invalid MongoSess option: Servers')
  }

  // Create server(s). 
  if (opts.servers.length === 1) {

    server = opts.servers[0]

    // Port defaults to 27017.
    if (!server.port) server.port = 27017
    server = new Mongo.Server(server.host, server.port, server.opts || {})

    db = new Mongo.Db(opts.db, server, {w: 1})

  } else if (opts.servers.length > 1) {
    // Replica set servers.

    server = opts.servers.map(function (info) {
      return new Mongo.Server(info.host, info.port || 27017, info.opts || {})
    })

    db = new Mongo.Db(opts.db, new Mongo.ReplSetServers(server), {w: 1})
  }

  if (!server || !db) {
    throw new Error('MongoSess: trouble connecting.')
  }

  db.open(function (err, database) {
    if (err) throw err

    db = database

    // Authenticate if necessary.
    if (opts.auth) {
      db.authenticate(opts.auth.user, opts.auth.pass,
        function (err) {
          if (err) throw new Error('Trouble authenticating\n' + err)


          createCollection(opts, cb)
        })
    } else {
      createCollection(opts, cb)
    }
  })
}

/**
 * MongoSess.close() closes the connection.
 * @return {Boolean}
 */
MongoSess.close = MongoSess.disconnect = function () {
  if (!db) return false

  db.close()
  db = collection = null

  return true
}
